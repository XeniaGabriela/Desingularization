                     SINGULAR                                 /
 A Computer Algebra System for Polynomial Computations       /   version 3-1-2
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   Oct 2010
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \
> LIB "all.lib";

proc testideal(i) {
	if(i == 0)
	{
		ideal result=1;
		return(result);
	}
	i=std(i);
        int ht=nvars(basering)-dim(i);
	ideal j=minor(jacob(i),ht);
	ideal tmp=i,j;
	ideal result=radical(tmp);
	return(result);
}


proc isnor(ideal i)
{       def BAS = basering;

        if (dim(i) == -1)
        {
            int isn = 1; 
            return(isn);
        }

        ideal j = testideal(i);
        qring q = std(i);
        setring q;
        ideal j = fetch(BAS,j);
        poly a = j[1];
	ideal aJJ=quotient(a*j,j);            
	aJJ=std(aJJ);
	ideal aa=a;
	aa=std(aa);
	ideal rf = interred(reduce(aJJ,aa));

	if (size(rf)==0)
        {
         int isn = 1;
        }
         
        else
        {
         int isn = 0;
        }

        return(isn);
        setring BAS;
}


proc substpart(ideal endid, ideal endphi, int homo, intvec rw)
{
   def newRing = basering;
   int ii,jj;
   map phi = newRing,maxideal(1);    
   list Le = elimpart(endid);
   int q = size(Le[2]);    
   intvec rw1 = 0;        
   rw1[nvars(basering)] = 0;
   rw1 = rw1+1;            //rw1=1,..,1 (as many 1 as nvars(basering))

   while( size(Le[2]) != 0 )
   {
      endid = Le[1];
      if ( defined(ps) )
      { kill ps; }
      map ps = newRing,Le[5];
      phi = ps(phi);
      for(ii=1;ii<=size(Le[2]);ii++)
      {
         phi=phi(phi);
      }
      //eingefuegt wegen x2-y2z2+z3

      for( ii=1; ii<=size(rw1); ii++ )
      {
         if( Le[4][ii]==0 )        //ii = index of var which was substituted
         {
            rw1[ii]=0;             //substituted vars have entry 0 in rw1
         }
      }
      Le=elimpart(endid);          //repeated application of elimpart
      q = q + size(Le[2]);
   }
   endphi = phi(endphi);
   if( nvars(newRing) == q )
   {
     ring lastRing = char(basering),T(1),dp;
     ideal endid = T(1);
     ideal endphi = T(1);
     for(ii=2; ii<=q; ii++ )
     {
        endphi[ii] = 0;
     }
     export(endid,endphi);
     list L = lastRing;
     setring newRing;
     return(L);
   }

   if (homo==1 && nvars(newRing)-q >1 && size(endid) >0 )
   {
      jj=1;
      for( ii=2; ii<size(rw1); ii++)
      {
         jj++;
         if( rw1[ii]==0 )
         {
            rw=rw[1..jj-1],rw[jj+1..size(rw)];
            jj=jj-1;
         }
      }
      if( rw1[1]==0 ) { rw=rw[2..size(rw)]; }
      if( rw1[size(rw1)]==0 ){ rw=rw[1..size(rw)-1]; }

      ring lastRing = char(basering),(T(1..nvars(newRing)-q)),(a(rw),dp);
   }
   else
   {
      ring lastRing = char(basering),(T(1..nvars(newRing)-q)),dp;
   }
   ideal lastmap;
   jj = 1;

   for(ii=1; ii<=size(rw1); ii++ )
   {
      if ( rw1[ii]==1 ) { lastmap[ii] = T(jj); jj=jj+1; }
      if ( rw1[ii]==0 ) { lastmap[ii] = 0; }
   }
   map phi1 = newRing,lastmap;
   ideal endid  = phi1(endid);      //### bottelneck
   ideal endphi = phi1(endphi);

/*
Versuch: subst statt phi
   for(ii=1; ii<=size(rw1); ii++ )
   {
      if ( rw1[ii]==1 ) { endid = subst(endid,var(ii),T(jj)); }
      if ( rw1[ii]==0 ) { endid = subst(endid,var(ii),0); }
   }
*/
   export(endid);
   export(endphi);
   list L = lastRing;
   setring newRing;
   return(L);
}
      
       
proc lipman(list li)                        
{     
 //--- assertion: i radical ideal

       def BAS=basering;
       ideal irad=radical(i);
       if(size(reduce(irad,std(i)))!=0)
       {
           "WARNING! The input is not reduced!";
           "We will continue with the reduced part of input";
            i=irad;
       }

       
       if (size(i) == 0)
       {  
            ideal s = 1;
       }

       else
       {
            ideal s = std(radical(slocus(i)));
       }
       
       int e = isnor(i);
       e;
       int d = dim(s);
       d;

       if (d == -1)                                                    
  //---singular locus is emptyset
       {     
             ideal lip = i;
             lip;

             if (defined(liph))                                          //--- funktioniert auf jeden Fall, falls keine Aufblasung vorher war
             {
                  ideal lipmap = liph;
             }

             else
             {
                  ideal lipmap = maxideal(1);
             }

             export(lip);
             export(lipmap);
             result[jj]= BAS,"lip","lipmap";
       }
     
         
       if (e == 1 && d > -1)
  //---BAS/i is normal and singular
       {
             list b = blowUp2(i,s);
             b;
             int r=size(b);
             int k;
             list isno;
             export(isno);
             for (k=1;k<=r;k++)
             {
                  def Newr1 = b[k];
                  setring Newr1;
                  ideal i =  std(Jnew,radical(eD));

                  if (isnor(i) == 1)
                       { isno[k] = 1;}
              
                  map phi = BAS,bM;

                  if (defined(liph))
                       { ideal liph = phi(liph);}
                  else
                       { ideal liph = bM;}
       
                  export(liph);
                  setring BAS;
              }
           
             return(b);
       }

       if (e == 0)
  //---BAS/i is not normal
       {
             list n = normal(i); 
             list li;  
             intvec rw; 
             int rr=size(n[1]);
             int kk;
             for (kk=1;kk<=rr;kk++)
             {                      
                  def Newrk = n[1][kk];                         
                  setring Newrk;
                  map phi = BAS,normap;
 
                  if (defined(liph))
                       { ideal normap = phi(liph);}
                       
                  int homo = homog(norid);

                  if( homo==1 )
                       { rw = ringweights(BAS);}

                  list L = substpart(norid,normap,homo,rw);
                  def newrk = L[1];
                  setring newrk;
                  ideal i = endid;
                  export(i);
                  ideal liph = endphi;
                  export(liph);
                  li[kk] = newrk;
                  setring BAS;
                  kill homo,L,Newrk,newrk;
             }  

       }
        
        return(li);
};
                             

// ** loaded /usr/share/Singular/LIB/all.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/qmatrix.lib (13334,2010-09-29)
// ** loaded /usr/share/Singular/LIB/perron.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/nctools.lib (13467,2010-10-13)
// ** loaded /usr/share/Singular/LIB/ncdecomp.lib (12790,2010-05-14)
// ** loaded /usr/share/Singular/LIB/ncalg.lib (13403,2010-10-06)
// ** loaded /usr/share/Singular/LIB/involut.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/gkdim.lib (12235,2009-11-03)
// ** loaded /usr/share/Singular/LIB/freegb.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/dmodvar.lib (13492,2010-10-14)
// ** loaded /usr/share/Singular/LIB/dmodapp.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/dmod.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/central.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/bfun.lib (13483,2010-10-13)
// ** loaded /usr/share/Singular/LIB/zeroset.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/weierstr.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/tropical.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/triang.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/toric.lib (12330,2009-11-26)
// ** loaded /usr/share/Singular/LIB/teachstd.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/surfex.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/surf.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/stratify.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/spectrum.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/spcurve.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/solve.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/signcond.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/sing4ti2.lib (13269,2010-09-23)
// ** loaded /usr/share/Singular/LIB/sing.lib (12394,2010-01-04)
// ** loaded /usr/share/Singular/LIB/sheafcoh.lib (13328,2010-09-29)
// ** loaded /usr/share/Singular/LIB/sagbi.lib (13505,2010-10-15)
// ** loaded /usr/share/Singular/LIB/rootsur.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/rootsmr.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/rinvar.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/ring.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/reszeta.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/resolve.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/resgraph.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/resbin.lib $Id: resbin.lib$
// ** loaded /usr/share/Singular/LIB/reesclos.lib (1.32,2001/01/16)
// ** loaded /usr/share/Singular/LIB/redcgs.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/realrad.lib (13352,2010-09-30)
// ** loaded /usr/share/Singular/LIB/random.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/qhmoduli.lib (12790,2010-05-14)
// ** loaded /usr/share/Singular/LIB/primitiv.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/primdec.lib (13403,2010-10-06)
// ** loaded /usr/share/Singular/LIB/presolve.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/polymake.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/poly.lib (12443,2010-01-19)
// ** loaded /usr/share/Singular/LIB/pointid.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/phindex.lib (12571,2010-03-01)
// ** loaded /usr/share/Singular/LIB/ntsolve.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/normaliz.lib (12790,2010-05-14)
// ** loaded /usr/share/Singular/LIB/normal.lib (13488,2010-10-14)
// ** loaded /usr/share/Singular/LIB/noether.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/mregular.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/mprimdec.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/monomialideal.lib (13403,2010-10-06)
// ** loaded /usr/share/Singular/LIB/mondromy.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/modstd.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/matrix.lib (12898,2010-06-23)
// ** loaded /usr/share/Singular/LIB/makedbm.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/lll.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/linalg.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/latex.lib (13477,2010-10-13)
// ** loaded /usr/share/Singular/LIB/kskernel.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/jacobson.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/intprog.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/inout.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/hyperel.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/homolog.lib (12381,2009-12-11)
// ** loaded /usr/share/Singular/LIB/hnoether.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/grwalk.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/groups.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/graphics.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/gmssing.lib (13548,2010-10-19)
// ** loaded /usr/share/Singular/LIB/gmspoly.lib (12529,2010-02-08)
// ** loaded /usr/share/Singular/LIB/general.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/finvar.lib (13326,2010-09-29)
// ** loaded /usr/share/Singular/LIB/equising.lib (13483,2010-10-13)
// ** loaded /usr/share/Singular/LIB/elim.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/deform.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/decodegb.lib (13483,2010-10-13)
// ** loaded /usr/share/Singular/LIB/curvepar.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/crypto.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/control.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/compregb.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/classify.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/cimonom.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/brnoeth.lib (13312,2010-09-29)
// ** loaded /usr/share/Singular/LIB/atkins.lib (12932,2010-06-30)
// ** loaded /usr/share/Singular/LIB/assprimeszerodim.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/arcpoint.lib (12231,2009-11-02)
// ** loaded /usr/share/Singular/LIB/algebra.lib (12436,2010-01-15)
// ** loaded /usr/share/Singular/LIB/alexpoly.lib (13499,2010-10-15)
// ** loaded /usr/share/Singular/LIB/aksaka.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/ainvar.lib (13536,2010-10-18)
// ** loaded /usr/share/Singular/LIB/absfact.lib (13534,2010-10-18)
. ;
> proc lippi(ideal i)
{
//--- assertion: i radical ideal

       def BAS=basering;
       ideal irad=radical(i);
       if(size(reduce(irad,std(i)))!=0)
       {
           "WARNING! The input is not reduced!";
           "We will continue with the reduced part of input";
            i=irad;
       }

       
       if (size(i) == 0)
       {  
            ideal s = 1;
       }

       else
       {
            ideal s = std(radical(slocus(i)));
       }
       
       int e = isnor(i);
       e;
       int d = dim(s);
       d;
if (e == 0)
  //---BAS/i is not normal
       {
             list n = normal(i); 
             list li; 
             intvec rw;  
             int rr=size(n[1]);
             int kk;
             for (kk=1;kk<=rr;kk++)
             {                      
                  def Newrk = n[1][kk];                         
                  setring Newrk;
                  map phi = BAS,normap;
 
                  if (defined(liph))
                       { ideal normap = phi(liph);}
                       
                  int homo = homog(norid);

                  if( homo==1 )
                       { rw = ringweights(BAS);}

                  list L = substpart(norid,normap,homo,rw);
                  def newrk = L[1];
                  setring newrk;
                  ideal i = endid;
                  export(i);
                  ideal liph = endphi;
                  export(liph);
                  li[kk] = newrk;
                  setring BAS;
                  kill Newrk,newrk,homo,L;
             }  
            
           return(li);

       }

};

. ;
> ring r=0,(x,y,z),dp;
> ideal i=x2+y3z3+y2z5;
> isnor(i);
0
> ideal s=slocus(i);
> s;
s[1]=y2z5+y3z3+x2
s[2]=5y2z4+3y3z2
s[3]=2yz5+3y2z3
s[4]=2x
> s=radical(s);
> s;
s[1]=x
s[2]=yz
> dim(s);
// ** s is no standard basis
1
> list n=normal(i);

// 'normal' created a list, say nor, of two elements.
// To see the list type
      nor;

// * nor[1] is a list of 1 ring(s).
// To access the i-th ring nor[1][i], give it a name, say Ri, and type
     def R1 = nor[1][1]; setring R1; norid; normap;
// For the other rings type first (if R is the name of your base ring)
     setring R;
// and then continue as for R1.
// Ri/norid is the affine algebra of the normalization of R/P_i where
// P_i is the i-th component of a decomposition of the input ideal id
// and normap the normalization map from R to Ri/norid.

// * nor[2] is a list of 1 ideal(s). Let ci be the last generator
// of the ideal nor[2][i]. Then the integral closure of R/P_i is
// generated as R-submodule of the total ring of fractions by
// 1/ci * nor[2][i].
> n;
[1]:
   [1]:
      //   characteristic : 0
//   number of vars : 4
//        block   1 : ordering dp
//                  : names    T(1)
//        block   2 : ordering dp
//                  : names    x y z
//        block   3 : ordering C
[2]:
   [1]:
      _[1]=yz4+y2z2
      _[2]=x
> def Newrk=n[1][1];
> setring Newrk;
> int homo=homog(norid);
> homo;
0
> intvec rw;
> list L=substpart(norid,normap,homo,rw);
> L;
[1]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    T(1) T(2) T(3)
//        block   2 : ordering C
> norid;
norid[1]=T(1)*y*z+x
norid[2]=-T(1)*x+y*z^4+y^2*z^2
norid[3]=T(1)^2+z^3+y*z
norid[4]=y^2*z^5+y^3*z^3+x^2
> ideal s=radical(slocus(norid));
> s;
s[1]=z
s[2]=y
s[3]=x
s[4]=T(1)
> def newrk=L[1];
> setring newrk;
> i;
   ? `i` is undefined
   ? error occurred in or before STDIN line 703: `i;`
> endid;
endid[1]=T(2)*T(3)^4+T(1)^2*T(2)*T(3)+T(2)^2*T(3)^2
endid[2]=T(3)^3+T(1)^2+T(2)*T(3)
endid[3]=T(2)^2*T(3)^5+T(1)^2*T(2)^2*T(3)^2+T(2)^3*T(3)^3
> endphi;
endphi[1]=-T(1)*T(2)*T(3)
endphi[2]=T(2)
endphi[3]=T(3)
> ideal s=radical(slocus(norid));
   ? `norid` is undefined
   ? error occurred in or before sing.lib::slocus line 369: `parameter ideal i;  `
   ? expected ideal-expression. type 'help ideal;'
   ? leaving sing.lib::slocus
   skipping text from `)` error at token `)`
> ideal s=radical(slocus(endphi));
// ** redefining s **
> s;
s[1]=1
> ideal s=radical(slocus(endid));
// ** redefining s **
> s;
s[1]=T(3)
s[2]=T(2)
s[3]=T(1)
> list b = blowUp2(i,s);
   ? `i` is undefined
   ? error occurred in or before resolve.lib::blowUp2 line 293: `parameter ideal J; parameter ideal C;  `
   ? leaving resolve.lib::blowUp2
   skipping text from `;` error at token `)`
> list b = blowUp2(endid,s);
// ** redefining b **
> b;
[1]:
   //   characteristic : 0
//   number of vars : 2
//        block   1 : ordering dp
//                  : names    y(2) y(3)
//        block   2 : ordering C
[2]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(2) y(1) y(3)
//        block   2 : ordering C
[3]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(3) y(1) y(2)
//        block   2 : ordering C
> def r1=b[1];
> setring r1;
> eD;
eD[1]=y(3)^2+y(2)
> Jnew;
Jnew[1]=0
> ideal i =  std(Jnew,radical(eD));
> i;
i[1]=y(3)^2+y(2)
> isnor(i);
1
> radical(slocus(i));
_[1]=1
> def r2=b[2];
> setring r2;
> eD;
eD[1]=x(2)
eD[2]=y(3)^2+y(1)
> Jnew;
Jnew[1]=x(2)*y(1)^3+y(3)^2+y(1)
> ideal i =  std(Jnew,radical(eD));
> i;
i[1]=x(2)
i[2]=y(3)^2+y(1)
> isno(i);
   ? `isno` is not defined
   ? error occurred in or before STDIN line 729: `(i);`
> isnor(i);
1
> radical(slocus(i));
_[1]=1
> def r3=b[3];
> setring b3;
   ? b3 is no name of a ring/qring
   ? error occurred in or before STDIN line 733: `setring b3;`
> setring r3;
> ideal i =  std(Jnew,radical(eD));
> i;
i[1]=x(3)
i[2]=y(1)*y(2)+1
> isnor(i);
1
> radical(slocus(i));
_[1]=1
> list m;
> m[2]=2;
   ? `m82m9` is undefined
   ? error occurred in or before STDIN line 741: `m[2]=2;`
> m[2]=2;
> m[4]=4;
> m;
[2]:
   2
[4]:
   4
> size(m);
4
> defined(m[1]);
1
> m[1];
`_`
> help;
// ** Displaying help in browser 'emacs'.
// ** Use 'system("--browser", <browser>);' to change browser,
// ** where <browser> can be: "htmlview", "firefox", "xinfo", "info", "builtin", "dummy", "emacs".
// ** Your help command could not be executed. Use
// ** C-h C-s Top
// ** to enter the Singular online help. For general
// ** information on Singular running under Emacs, type C-h m.
> m=1,..,1;
   ? error occurred in or before STDIN line 749: `m=1,..,1;`
   skipping text from `,`
> list n;
> n=1,1,1,1;
> n;
[1]:
   1
[2]:
   1
[3]:
   1
[4]:
   1
> m;
[2]:
   2
[4]:
   4
> proc lippi(ideal i)
{
//--- assertion: i radical ideal
     def BAS=basering;
     ideal irad=radical(i);
     if(size(reduce(irad,std(i)))!=0)
     {
         "WARNING! The input is not reduced!";
         "We will continue with the reduced part of input";
          i=irad;
     }

     if (size(i) == 0)
     {  
         ideal s = 1;
     }

     else
     {
         ideal s = std(radical(slocus(i)));
     }
       
     int e = isnor(i);
     e;
     int d = dim(s);
     d;
     list nm;

if (e == 1 && d > -1)
  //---BAS/i is normal and singular
     {
         list b = blowUp2(i,s);
         b;
         int r=size(b);
         int k;
         list isno;
         export(isno);
         for (k=1;k<=r;k++)
         {
             def Newr1 = b[k];
             setring Newr1;
             ideal i = std(Jnew,radical(eD));
             ideal s =radical(slocus(Jnew));

             if (isnor(i) == 1 && dim(s) == -1)
             { 
                nm[k][1] = Newr1;
                ideal i = lip;
                ideal liph = bM;
                export(lip);
                export(liph);
                
             }
             
             else
             { 
                e = 0;
             }
         }
     }


if (e == 0)
  //---BAS/i is not normal
     {
         list n = normal(i); 
         intvec rw;  
         int rr=size(n[1]);
         int kk;
         for (kk=1;kk<=rr;kk++)
         {                      
             def Newrk = n[1][kk];                         
             setring Newrk;
             map phi = BAS,normap;
 
             if (defined(liph))
                { ideal normap = phi(liph);}
                       
             int homo = homog(norid);

             if( homo==1 )
                { rw = ringweights(BAS);}

             list L = substpart(norid,normap,homo,rw);
             def newrk = L[1];
             setring newrk;
             ideal i = endid;
             ideal s = std(radical(slocus(i)));

             if (dim(s) == -1)
             {    
                 nm[kk][1] = newrk;
                 ideal lip = i;
                 ideal liph = endphi;
                 export(lip);
                 export(liph);
                 kill Newrk,homo,L;
             }
                
             
             if (dim(s) <=0)
             {
                 list b = blowUp2(i,s);
                 b;
                 int r = size(b);
                 int k;
                 list isno;
                 for (k=1;k<=r;k++)
                 {
                     def Newr1 = b[k];
                     setring Newr1;
                     ideal lip = std(Jnew,radical(eD));
                     map phi = BAS,bM;

                     if (defined(liph))
                     { ideal liph = phi(liph);}

                     else
                     { ideal liph = bM;}
       
                     export(liph);

                     if (isnor(i) == 1)
                     { 
                        isno[k] = 1; 
                        nm[kk][1][k]= Newr1;
                        export(lip);
                     }
                 }
             }  
         }
     }

     setring BAS;
     return(nm);
};
// ** redefining lippi **
> i
. i;
i[1]=x(3)
i[2]=y(1)*y(2)+1
   ? error occurred in or before STDIN line 1024: `i;`
   skipping text from `;`
> setring r;
> i;
i[1]=y2z5+y3z3+x2
> lippi(i);
0
1
[1]:
   //   characteristic : 0
//   number of vars : 2
//        block   1 : ordering dp
//                  : names    y(2) y(3)
//        block   2 : ordering C
[2]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(2) y(1) y(3)
//        block   2 : ordering C
[3]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(3) y(1) y(2)
//        block   2 : ordering C
   ? `i` is undefined
   ? error occurred in or before ::isnor line 0: `parameter ideal i; `
   ? wrong type declaration. type 'help ideal;'
   ? leaving ::isnor
   skipping text from ` `   ? leaving ::lippi
 error at token `)`
> proc lippi(ideal i)
{
//--- assertion: i radical ideal
     def BAS=basering;
     ideal irad=radical(i);
     if(size(reduce(irad,std(i)))!=0)
     {
         "WARNING! The input is not reduced!";
         "We will continue with the reduced part of input";
          i=irad;
     }

     if (size(i) == 0)
     {  
         ideal s = 1;
     }

     else
     {
         ideal s = std(radical(slocus(i)));
     }
       
     int e = isnor(i);
     e;
     int d = dim(s);
     d;
     list nm;

if (e == 1 && d > -1)
  //---BAS/i is normal and singular
     {
         list b = blowUp2(i,s);
         b;
         int r=size(b);
         int k;
         list isno;
         export(isno);
         for (k=1;k<=r;k++)
         {
             def Newr1 = b[k];
             setring Newr1;
             ideal i = std(Jnew,radical(eD));
             ideal s =radical(slocus(Jnew));

             if (isnor(i) == 1 && dim(s) == -1)
             { 
                nm[k][1] = Newr1;
                ideal i = lip;
                ideal liph = bM;
                export(lip);
                export(liph);
                
             }
             
             else
             { 
                e = 0;
             }
         }
     }


if (e == 0)
  //---BAS/i is not normal
     {
         list n = normal(i); 
         intvec rw;  
         int rr=size(n[1]);
         int kk;
         for (kk=1;kk<=rr;kk++)
         {                      
             def Newrk = n[1][kk];                         
             setring Newrk;
             map phi = BAS,normap;
 
             if (defined(liph))
                { ideal normap = phi(liph);}
                       
             int homo = homog(norid);

             if( homo==1 )
                { rw = ringweights(BAS);}

             list L = substpart(norid,normap,homo,rw);
             def newrk = L[1];
             setring newrk;
             ideal i = endid;
             ideal s = std(radical(slocus(i)));

             if (dim(s) == -1)
             {    
                 nm[kk][1] = newrk;
                 ideal lip = i;
                 ideal liph = endphi;
                 export(lip);
                 export(liph);
                 kill Newrk,homo,L;
             }
                
             
             if (dim(s) <=0)
             {
                 list b = blowUp2(i,s);
                 b;
                 int r = size(b);
                 int k;
                 list isno;
                 for (k=1;k<=r;k++)
                 {
                     def Newr1 = b[k];
                     setring Newr1;
                     ideal lip = std(Jnew,radical(eD));
                     map phi = BAS,bM;

                     if (defined(liph))
                     { ideal liph = phi(liph);}

                     else
                     { ideal liph = bM;}
       
                     export(liph);

                     if (isnor(lip) == 1)
                     { 
                        isno[k] = 1; 
                        nm[kk][1][k]= Newr1;
                        export(lip);
                     }
                 }
             }  
         }
     }

     setring BAS;
     return(nm);
};
// ** redefining lippi **
> setring r;
> i;
i[1]=y2z5+y3z3+x2
> lippi(i);
0
1
[1]:
   //   characteristic : 0
//   number of vars : 2
//        block   1 : ordering dp
//                  : names    y(2) y(3)
//        block   2 : ordering C
[2]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(2) y(1) y(3)
//        block   2 : ordering C
[3]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(3) y(1) y(2)
//        block   2 : ordering C
   ? `nothing` [ `int` failed
   ? expected `intvec` [ `int`
   ? expected `ideal` [ `int`
   ? expected `map` [ `int`
   ? expected `module` [ `int`
   ? expected `string` [ `int`
   ? expected `list` [ `int`
   ? expected `poly` [ `int`
   ? expected `vector` [ `int`
   ? error occurred in or before ::lippi line 122: `                        nm[kk][1][k]= Newr1;`
   ? leaving ::lippi
   skipping text from `;` error at token `)`
> list nm;
> nm[1][1]=2;
   ? `nothing` [ `int` failed
   ? expected `intvec` [ `int`
   ? expected `ideal` [ `int`
   ? expected `map` [ `int`
   ? expected `module` [ `int`
   ? expected `string` [ `int`
   ? expected `list` [ `int`
   ? expected `poly` [ `int`
   ? expected `vector` [ `int`
   ? error occurred in or before STDIN line 1301: `nm[1][1]=2;`
> nm[1]=0;
> nm;
[1]:
   0
> nm[1]=0,1,2;
   ? assign not impl.
   ? error occurred in or before STDIN line 1304: `nm[1]=0,1,2;`
> nm;
[1]:
   0
> nm[1][1]=1;
> nm[1][2]=2;
> nm;
[1]:
   0
> size(nm[1]);
0
> size(nm);
1
> proc lippi(ideal i)
{
//--- assertion: i radical ideal
     def BAS=basering;
     ideal irad=radical(i);
     if(size(reduce(irad,std(i)))!=0)
     {
         "WARNING! The input is not reduced!";
         "We will continue with the reduced part of input";
          i=irad;
     }

     if (size(i) == 0)
     {  
         ideal s = 1;
     }

     else
     {
         ideal s = std(radical(slocus(i)));
     }
       
     int e = isnor(i);
     e;
     int d = dim(s);
     d;
     list nm;

if (e == 1 && d > -1)
  //---BAS/i is normal and singular
     {
         list b = blowUp2(i,s);
         b;
         int r=size(b);
         int k;
         list isno;
         export(isno);
         for (k=1;k<=r;k++)
         {
             def Newr1 = b[k];
             setring Newr1;
             ideal i = std(Jnew,radical(eD));
             ideal s =radical(slocus(Jnew));

             if (isnor(i) == 1 && dim(s) == -1)
             { 
                nm[k][1] = Newr1;
                ideal i = lip;
                ideal liph = bM;
                export(lip);
                export(liph);
                
             }
             
             else
             { 
                e = 0;
             }
         }
     }


if (e == 0)
  //---BAS/i is not normal
     {
         list n = normal(i); 
         intvec rw;  
         int rr=size(n[1]);
         int kk;
         for (kk=1;kk<=rr;kk++)
         {                      
             def Newrk = n[1][kk];                         
             setring Newrk;
             map phi = BAS,normap;
 
             if (defined(liph))
                { ideal normap = phi(liph);}
                       
             int homo = homog(norid);

             if( homo==1 )
                { rw = ringweights(BAS);}

             list L = substpart(norid,normap,homo,rw);
             def newrk = L[1];
             setring newrk;
             ideal i = endid;
             ideal s = std(radical(slocus(i)));

             if (dim(s) == -1)
             {    
                 nm[kk] = newrk;
                 ideal lip = i;
                 ideal liph = endphi;
                 export(lip);
                 export(liph);
                 kill Newrk,homo,L;
             }
                
             
             if (dim(s) <=0)
             {
                 list b = blowUp2(i,s);
                 b;
                 int r = size(b);
                 int k;
                 list isno;
                 for (k=1;k<=r;k++)
                 {
                     def Newr1 = b[k];
                     setring Newr1;
                     ideal lip = std(Jnew,radical(eD));
                     map phi = BAS,bM;

                     if (defined(liph))
                     { ideal liph = phi(liph);}

                     else
                     { ideal liph = bM;}
       
                     export(liph);

                     if (isnor(lip) == 1)
                     { 
                        isno[k] = 1; 
                        nm[k]= Newr1;
                        export(lip);
                     }
                 }
             }  
         }
     }

     setring BAS;
     return(nm);
};
// ** redefining lippi **
> i;
i[1]=y2z5+y3z3+x2
> lippi(i);
0
1
[1]:
   //   characteristic : 0
//   number of vars : 2
//        block   1 : ordering dp
//                  : names    y(2) y(3)
//        block   2 : ordering C
[2]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(2) y(1) y(3)
//        block   2 : ordering C
[3]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(3) y(1) y(2)
//        block   2 : ordering C
// ** redefining Newr1 **
// ** redefining Newr1 **
[1]:
   //   characteristic : 0
//   number of vars : 2
//        block   1 : ordering dp
//                  : names    y(2) y(3)
//        block   2 : ordering C
[2]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(2) y(1) y(3)
//        block   2 : ordering C
[3]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(3) y(1) y(2)
//        block   2 : ordering C
> isno;
   ? `isno` is undefined
   ? error occurred in or before STDIN line 1582: `isno;`
> proc lippi(ideal i)
{
//--- assertion: i radical ideal
     def BAS=basering;
     ideal irad=radical(i);
     if(size(reduce(irad,std(i)))!=0)
     {
         "WARNING! The input is not reduced!";
         "We will continue with the reduced part of input";
          i=irad;
     }

     if (size(i) == 0)
     {  
         ideal s = 1;
     }

     else
     {
         ideal s = std(radical(slocus(i)));
     }
       
     int e = isnor(i);
     e;
     int d = dim(s);
     d;
     list nm;

if (e == 1 && d > -1)
  //---BAS/i is normal and singular
     {
         list b = blowUp2(i,s);
         int r=size(b);
         int k;
         list isno;
         for (k=1;k<=r;k++)
         {
             def Newr1 = b[k];
             setring Newr1;
             ideal i = std(Jnew,radical(eD));
             ideal s =radical(slocus(Jnew));
             isno[k]=isnor(i);

             if (isnor(i) == 1 && dim(s) == -1)
             { 
                nm[k][1] = Newr1;
                ideal i = lip;
                ideal liph = bM;
                export(lip);
                export(liph);
                
             }
             
             else
             { 
                e = 0;
             }
         }
     }


if (e == 0)
  //---BAS/i is not normal
     {
         list n = normal(i); 
         intvec rw;  
         int rr=size(n[1]);
         int kk;
         for (kk=1;kk<=rr;kk++)
         {                      
             def Newrk = n[1][kk];                         
             setring Newrk;
             map phi = BAS,normap;
 
             if (defined(liph))
                { ideal normap = phi(liph);}
                       
             int homo = homog(norid);

             if( homo==1 )
                { rw = ringweights(BAS);}

             list L = substpart(norid,normap,homo,rw);
             def newrk = L[1];
             setring newrk;
             ideal i = endid;
             ideal s = std(radical(slocus(i)));

             if (dim(s) == -1)
             {    
                 nm[kk] = newrk;
                 ideal lip = i;
                 ideal liph = endphi;
                 export(lip);
                 export(liph);
                 kill Newrk,homo,L;
             }
                
             
             if (dim(s) <= 0)
             {
                 list b = blowUp2(i,s);
                 int r = size(b);
                 int k;
                 list isno;
                 export(isno);
                 for (k=1;k<=r;k++)
                 {
                     def Newr1 = b[k];
                     setring Newr1;
                     ideal i = std(Jnew,radical(eD));
                     map phi = BAS,bM;

                     if (defined(liph))
                     { ideal liph = phi(liph);}

                     else
                     { ideal liph = bM;}
       
                     export(liph);
                     isno[k]= isnor(i);

                     if (isno[k] == 1)
                     {  
                        nm[k]= Newr1;
                        ideal lip = i;
                        export(lip);
                     }
                 }
             }  
         }
     }

     setring BAS;
     return(nm);
};
// ** redefining lippi **
> lippi(i);
0
1
// ** redefining Newr1 **
// ** redefining Newr1 **
[1]:
   //   characteristic : 0
//   number of vars : 2
//        block   1 : ordering dp
//                  : names    y(2) y(3)
//        block   2 : ordering C
[2]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(2) y(1) y(3)
//        block   2 : ordering C
[3]:
   //   characteristic : 0
//   number of vars : 3
//        block   1 : ordering dp
//                  : names    x(3) y(1) y(2)
//        block   2 : ordering C
> isno;
[1]:
   1
[2]:
   1
[3]:
   1
> list lip=lippi(i);
0
1
// ** redefining isno
   ? ...parse error
   ? error occurred in or before ::lippi line 123: `                        export(lip);`
   ? leaving ::lippi
   skipping text from `;` error at token `)`
> setring r;
> i;
i[1]=y2z5+y3z3+x2
> lippi(i);
0
1
// ** redefining isno
   ? ...parse error
   ? error occurred in or before ::lippi line 123: `                        export(lip);`
   ? leaving ::lippi
   skipping text from `;` error at token `)`
> exit;
Auf Wiedersehen.
